#include "time.hpp"
#include "parse_args.hpp"
#include "check_inputs.hpp"
#include "bloom_filter.hpp"
#include "count_solid_kmers.hpp"
#include "correct_errors.hpp"



//----------------------------------------------------------------------
// main
//----------------------------------------------------------------------
int main(int argc, char** argv) {

   // construct initial classes
   C_time c_inst_time;
   C_arg  c_inst_args(argc, argv, c_inst_time);
//   C_memory c_inst_memory;

   // check input read files
   C_check_read c_inst_check_reads;
   c_inst_check_reads.check_read_file(c_inst_args, c_inst_time);

   // construct a class to count the number of unique k-mers
   C_count_solid_kmers c_inst_count_solid_kmers;
   c_inst_count_solid_kmers.kmer_occurrence_threshold = c_inst_args.kmer_occurrence_threshold;

   // distribute k-mers into multiple files
   c_inst_count_solid_kmers.distribute_kmers(c_inst_args, c_inst_check_reads, c_inst_time);

   // count k-mers
   c_inst_count_solid_kmers.count_kmers(c_inst_args, c_inst_check_reads, c_inst_time);

   // construct a class to correct errors
   C_correct_errors c_inst_correct_errors;
   c_inst_correct_errors.num_unique_solid_kmers                   = (std::size_t)(c_inst_count_solid_kmers.num_unique_solid_kmers);
   c_inst_correct_errors.distributed_num_unique_solid_kmers       = c_inst_count_solid_kmers.distributed_num_unique_solid_kmers;
   c_inst_correct_errors.distributed_unique_solid_kmer_file_names = c_inst_count_solid_kmers.distributed_unique_solid_kmer_file_names;
   c_inst_correct_errors.read_length                              = c_inst_check_reads.read_length;
   c_inst_correct_errors.quality_score_offset                     = c_inst_check_reads.quality_score_offset;

   // program k-mers into a Bloom filter
   c_inst_correct_errors.generate_bloom_filter(c_inst_args, c_inst_time);
   c_inst_correct_errors.program_kmers(c_inst_args, c_inst_time);

   // program k-mers to the Bloom filter
   c_inst_correct_errors.correct_errors_in_reads(c_inst_args, c_inst_time);

   // Mark unique solid k-mers in reads
   if (c_inst_args.debug == true) {
      c_inst_correct_errors.mark_bloom_filter_results_org(c_inst_args, c_inst_time);
   }

   if (c_inst_args.verify == true) {
      // destroy a Bloom filter
      c_inst_correct_errors.c_inst_bloom_filter.min_size_bit_vector();

      // find false positive candidates
      c_inst_correct_errors.find_false_positive_candidates(c_inst_args, c_inst_time);

      // verify the number of occurreces of false positive candidate k-mers
      c_inst_correct_errors.verify_false_positive_candidates(c_inst_args, c_inst_time);

      // correct corrections generated by false positives
      c_inst_correct_errors.correct_false_positives(c_inst_args, c_inst_time);
   }

   // delete k-mer files
   c_inst_correct_errors.remove_kmer_files(c_inst_args.num_clusters, c_inst_args.verify);

   // write corrected reads into output files
   if (c_inst_args.nowrite == false) {
      c_inst_correct_errors.write_corrected_reads(c_inst_args, c_inst_time);
   }

   // write a TEF file
   c_inst_correct_errors.write_tef(c_inst_args, c_inst_time);

   // remove error correction information files
   c_inst_correct_errors.remove_error_correction_info_files(c_inst_args, c_inst_args.verify);

   // summarize output results
   c_inst_correct_errors.summarize_outputs(c_inst_args, c_inst_time);

   return (EXIT_SUCCESS);
}
